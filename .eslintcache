[{"D:\\repo\\react-snake\\src\\index.js":"1","D:\\repo\\react-snake\\src\\App.js":"2","D:\\repo\\react-snake\\src\\reportWebVitals.js":"3"},{"size":500,"mtime":499162500000,"results":"4","hashOfConfig":"5"},{"size":8168,"mtime":1611066745194,"results":"6","hashOfConfig":"5"},{"size":362,"mtime":499162500000,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"10"},"18jr72g",{"filePath":"11","messages":"12","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"13","usedDeprecatedRules":"10"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"D:\\repo\\react-snake\\src\\index.js",[],["17","18"],"D:\\repo\\react-snake\\src\\App.js",["19"],"import { useEffect, useRef, useState } from 'react';\nimport './App.scss';\n\nconst WORLD_WIDTH = 32;\nconst WORLD_HEIGHT = 24;\nconst DIRECTION = {\n  UP: 0,\n  DOWN: 1,\n  RIGHT: 2,\n  LEFT: 3,\n};\nconst DELAY = 50;\nconst SNAKES = [4, 3, 2, 1, 0];\nconst FOODS = [39];\n\nfunction useInterval(callback, delay) {\n  const savedCallback = useRef();\n\n  // Remember the latest function.\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  useEffect(() => {\n    const tick = () => {\n      savedCallback.current();\n    }\n\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}\n\nfunction App() {\n  const [snakes, setSnakes] = useState(SNAKES);\n  const [foods, setFoods] = useState(FOODS);\n  const [lose, setLose] = useState(false);\n  const [eat, setEat] = useState(0);\n  const [highestScore, setHighestScore] = useState(0);\n\n  const directionRef = useRef();\n  const disableEventRef = useRef();\n\n  const getRandomInt = (min, max) => {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n\n    return Math.floor(Math.random() * (max - min) + min);\n  }\n\n  const generateFoods = (currentSnakes, currentFoods) => {\n    let newFood = 0;\n    do {\n      newFood = getRandomInt(0, WORLD_WIDTH * WORLD_HEIGHT);\n    } while (currentSnakes.indexOf(newFood) !== -1 || currentFoods.indexOf(newFood) !== -1);\n\n    const newFoods = [...currentFoods];\n\n    newFoods.push(newFood);\n\n    setFoods(newFoods);\n  };\n\n  const move = () => {\n    if (lose) {\n      return;\n    }\n\n    let newSnakes = [...snakes];\n    let head = newSnakes[0];\n\n    switch(directionRef.current) {\n      case DIRECTION.RIGHT:\n        if ((head + 1) % WORLD_WIDTH === 0) {\n          head -= WORLD_WIDTH - 1;\n        } else {\n          head++;\n        }\n\n        break;\n      case DIRECTION.LEFT:\n        if (head % WORLD_WIDTH === 0) {\n          head += WORLD_WIDTH - 1;\n        } else {\n          head--;\n        }\n\n        break;\n      case DIRECTION.UP:\n        if (head < WORLD_WIDTH) {\n          head += (WORLD_HEIGHT - 1) * WORLD_WIDTH;\n        } else {\n          head -= WORLD_WIDTH;\n        }\n\n        break;\n      case DIRECTION.DOWN:\n        if (head >= WORLD_WIDTH * (WORLD_HEIGHT - 1)) {\n          head -= WORLD_WIDTH * (WORLD_HEIGHT - 1);\n        } else {\n          head += WORLD_WIDTH;\n        }\n\n        break;\n      default:\n        break;\n    }\n\n    if (snakes.indexOf(head) !== -1) {\n      if (eat > highestScore) {\n        setHighestScore(eat);\n      }\n\n      setLose(true);\n\n      return;\n    }\n\n    const eatenFoodIndex = foods.indexOf(head);\n\n    if (eatenFoodIndex !== -1) {\n      newSnakes = [head].concat(newSnakes);\n\n      let newFoods = [...foods];\n      newFoods.splice(eatenFoodIndex, 1);\n\n      generateFoods(newSnakes, newFoods);\n\n      setEat(eat + 1);\n    } else {\n      newSnakes = [head].concat(newSnakes.slice(0, newSnakes.length - 1));\n    }\n\n    setSnakes(newSnakes);\n  };\n\n  const findFood = () => {\n    const food = foods[0];\n    const head = snakes[0];\n   \n    const headHorizontalIndex = head % WORLD_WIDTH;\n    const foodHorizontalIndex = food % WORLD_WIDTH;\n\n    let newDirection = null;\n\n    if (headHorizontalIndex < foodHorizontalIndex) {\n      if (directionRef.current === DIRECTION.LEFT) {\n        newDirection = DIRECTION.UP;\n      } else {\n        newDirection = DIRECTION.RIGHT;\n      }\n    } else if (headHorizontalIndex > foodHorizontalIndex) {\n      if (directionRef.current === DIRECTION.RIGHT) {\n        newDirection = DIRECTION.UP;\n      } else {\n        newDirection = DIRECTION.LEFT;\n      }\n    } else {\n      const headVerticalIndex = Math.ceil(head / WORLD_HEIGHT);\n      const foodVerticalIndex = Math.ceil(food / WORLD_HEIGHT);\n  \n      if (headVerticalIndex < foodVerticalIndex) {\n        if (directionRef.current === DIRECTION.UP) {\n          newDirection = DIRECTION.RIGHT;\n        } else {\n          newDirection = DIRECTION.DOWN;\n        }\n      } else if (headVerticalIndex > foodVerticalIndex) {\n        if (directionRef.current === DIRECTION.DOWN) {\n          newDirection = DIRECTION.RIGHT;\n        } else {\n          newDirection = DIRECTION.UP;\n        }\n      }\n    }\n\n    let newHead = null;\n\n    switch (newDirection) {\n      case DIRECTION.RIGHT:\n        if ((head + 1) % WORLD_WIDTH === 0) {\n          newHead = head - (WORLD_WIDTH - 1);\n        } else {\n          newHead = head + 1;\n        }\n\n        break;\n      case DIRECTION.LEFT:\n        if (head % WORLD_WIDTH === 0) {\n          newHead = head + (WORLD_WIDTH - 1);\n        } else {\n          newHead = head - 1;\n        }\n\n        break;\n      case DIRECTION.UP:\n        if (head < WORLD_WIDTH) {\n          newHead = head + ((WORLD_HEIGHT - 1) * WORLD_WIDTH);\n        } else {\n          newHead = head - WORLD_WIDTH;\n        }\n\n        break;\n      case DIRECTION.DOWN:\n        if (head >= WORLD_WIDTH * (WORLD_HEIGHT - 1)) {\n          newHead = head - (WORLD_WIDTH * (WORLD_HEIGHT - 1));\n        } else {\n          newHead = head + WORLD_WIDTH;\n        }\n\n        break;\n      default:\n        break;\n    }\n\n    if (newHead === null) {\n      return;\n    }\n\n    if (snakes.indexOf(newHead) !== -1) {\n      return;\n    }\n\n    directionRef.current = newDirection;\n  };\n\n  const keydownHandler = (e) => {\n    if (disableEventRef.current) {\n      return;\n    }\n\n    switch (e.code) {\n      case 'ArrowRight':\n        if (directionRef.current === DIRECTION.LEFT) {\n          return;\n        }\n\n        directionRef.current = DIRECTION.RIGHT;\n\n        break;\n      case 'ArrowLeft':\n        if (directionRef.current === DIRECTION.RIGHT) {\n          return;\n        }\n\n        directionRef.current = DIRECTION.LEFT;\n\n        break;\n      case 'ArrowUp':\n        if (directionRef === DIRECTION.DOWN) {\n          return;\n        }\n\n        directionRef.current = DIRECTION.UP;\n\n        break;\n      case 'ArrowDown':\n        if (directionRef.current === DIRECTION.UP) {\n          return;\n        }\n\n        directionRef.current = DIRECTION.DOWN;\n\n        break;\n      default:\n        break;\n    }\n\n    disableEventRef.current = true;\n\n    setTimeout(() => {\n      disableEventRef.current = false;\n    }, DELAY);\n  };\n\n  useEffect(() => {\n    directionRef.current = DIRECTION.RIGHT;\n    disableEventRef.current = false;\n\n    // document.addEventListener('keydown', keydownHandler);\n  }, []);\n\n  useInterval(() => {\n    findFood();\n    move();\n  }, DELAY);\n\n  const renderWorld = () => {\n    const rows = [];\n\n    for (let i = 0, ii = WORLD_HEIGHT; i < ii; i++) {\n      const cols = [];\n\n      for (let j = 0, jj = WORLD_WIDTH; j < jj; j++) {\n        const index = i * WORLD_WIDTH + j;\n        let cellClassName = '';\n\n        if (snakes.indexOf(index) !== -1) {\n          cellClassName = ' snake';\n        } else if (foods.indexOf(index) !== -1) {\n          cellClassName = ' food';\n        }\n\n        cols.push(\n          <div key={`cell-${i}-${j}`} className={`w-cell${cellClassName}`}></div>\n        );\n      }\n\n      rows.push(\n        <div key={`row-${i}`} className=\"w-row\">{cols}</div>\n      );\n    }\n\n    return (\n      <div className=\"world\">{rows}</div>\n    );\n  };\n\n  const playAgainHandler = () => {\n    setSnakes([4, 3, 2, 1, 0]);\n    setFoods([39]);\n    setLose(false);\n    setEat(0);\n    directionRef.current = DIRECTION.RIGHT;\n  };\n\n  return (\n    <div className=\"app\">\n      <div className=\"world-container\">\n        {renderWorld()}\n        <div className=\"info\">\n          <span>react-snake</span>\n          <br />\n          <span>-----</span>\n          <br />\n          <span>highest score: {highestScore}</span>\n          <br />\n          <span>-----</span>\n          <br />\n          <span>food eaten: {eat}</span>\n          <br />\n          <span>snake's size: {snakes.length}</span>\n          {\n            lose && (\n              <>\n                <br />\n                <span>-----</span>\n                <br />\n                <span>lose, </span>\n                <span className=\"play-again\" onClick={playAgainHandler}>play again</span>\n              </>\n            )\n          }\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","D:\\repo\\react-snake\\src\\reportWebVitals.js",[],["20","21"],{"ruleId":"22","replacedBy":"23"},{"ruleId":"24","replacedBy":"25"},{"ruleId":"26","severity":1,"message":"27","line":231,"column":9,"nodeType":"28","messageId":"29","endLine":231,"endColumn":23},{"ruleId":"22","replacedBy":"30"},{"ruleId":"24","replacedBy":"31"},"no-native-reassign",["32"],"no-negated-in-lhs",["33"],"no-unused-vars","'keydownHandler' is assigned a value but never used.","Identifier","unusedVar",["32"],["33"],"no-global-assign","no-unsafe-negation"]